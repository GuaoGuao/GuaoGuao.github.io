---
title: 高性能网站建设指南
date: 2020-04-26 17:33:41
tags:
---
### 减少HTTP请求

* 图片地图(image map)：在一个图片上关联多个URL，点击不同位置，会弹出链接的相应页面，即<map>和<area>标签
* Css Sprites：将多个图片合并到一个单独的图片中，用坐标(background-position)取出这个图片，下载更快同事也降低了下载量
* 内联图片：图片src格式类似是"data::image/png;base64,iVAGRw0KGD"，不缓存，不支持ie8
* 合并脚本和样式表：更少的文件就有更少的请求

### 内容发布网络

* 内容发布网络(CDN)十一组分布在多个不同地理位置的Web服务器，能够更有效地向用户发布性能，能选择网络阶跃数最小的服务器。发布静态内容会很有优势

### 添加Expires头

* Expires Header 在HTTP响应中发送，是一个时间，作用是，告诉浏览器，在这个时间之前，都可以取缓存中的这个响应
* Expires Header 只返回时间，所以客户端和服务器的时间必须严格一致
* HTTP1.1 新增 Cache-Control头，其中是一些键值对，max-age以秒为单位标识缓存多久
* 带缓存的访问占40%-60%

### 压缩组件

* 添加HTTP头 Accept-Encoding: gzip或者deflate
* 图片和pdf不需要压缩，应该压缩脚本和样式表，大于1-2kb的文件
* 客户端要解压缩，服务端要压缩，要计算收益是否大于开销
* ![](/public/images/h1.png)
* 如何配置：Apache 1.3， 
    * mod_gzip_on    启用
    * mod_gzip_item_include    哪些需要压缩
    * mod_gzip_item_exclude    那些不需要压缩
* 当使用代理的时候，如果有缓存，压缩就会很复杂，url相同时有可能压缩，有可能不压缩，根据代理浏览器的支持程度，此时需要根据不同的请求通来缓存，增加头：Vary: Accept-Encoding

### 将样式表放在顶部


* CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染，位置不影响下载时间，区别是：
    * 放在顶部可以下载CSS同时解析DOM，提高并行度，页面逐步解析、逐步渲染、逐步呈现
    * 如果放在底部，先解析DOM，再下载CSS，时间长，渲染时间会白屏
    * 原理是浏览器为了避免样式变化时重绘页面，在样式下载完之前会阻止内容呈现
    * 放在顶部时候使用了@import导入其他样式，也可能导致白屏
* JS 阻塞 DOM 解析，阻止其他的下载，但浏览器会"偷看"DOM，预先下载相关资源。
* 浏览器遇到 script 且没有defer或async属性的 标签时，会触发页面渲染，因而如果前面CSS资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。
* FOUC：浏览器二次渲染无样式的DOM时候，重绘过程中会闪烁，样式表放在底部会导致这个

### 将脚本放在底部

* 脚本放在底部能够提高下载并行度，并且逐步呈现
* 如果把脚本放在不同的服务器上，可以使脚本并行下载，更快，2个主机是最快的
* 现实是脚本放在不同服务器也会阻塞下载
* async: 异步加载，不阻塞其他下载和渲染，加载完执行
* defer: 能使脚本延迟加载，不阻塞其他下载和渲染，等DOM解析完执行

### 避免CSS表达式

* ![](/public/images/h2.png)
* IE8就取消了expression，但现在有calc
* 触发很频繁，性能差
* 代替方法是使用js中时间监听改变样式

### 使用外部js和css

* 使用外部js和css能够使用缓存，如果是动态HTML，内联的js和css每次都会重新下载
* 如果必须用内联，可以用这个
    * 加载后下载： onload后setTimeout延迟1s，确保页面呈现完毕后创建一个link元素来下载，css和js都会加载两次，一次内联，一次link，内联的可以定义但不执行
    * 动态内联： 在js中判断cookie是否存在，存在的话说明这个页面有缓存，就使用外部js，没有的话就用内联的

### 减少DNS查找

* IP数据包中有个TTL，是ICMP协议的，是指途径网关数量。DNS协议中的TTL是指一条解析记录在DNS服务器上的缓存时间
* DNS缓存分两种：浏览器自己的缓存和DNS Client 中的缓存
* 通过Keep-Alive和较少的域名来减少DNS查找
* HTTP协议Connection: keep-alive
    * 请求响应之后不关闭连接，持续传输
    * Content-Length: 120 表示一共传输120字节，传输完关闭
    * Transfer-Encoding: chunked 表示分块传输，不必一次性传输完

### 精简JavaScript

* 混淆和精简
    * 混淆：移除注释和空白，修改函数和变量的名字，改写代码。通常用于防止反向工程，比精简更能减小代码。但是很难阅读、很难维护、很难调试
    * 精简：主要还是移除注释和空白，缩短变量和函数名
* 精简内联脚本
* 精简+压缩(gzip)，能更有效减小脚本大小
* ![](/public/images/h3.png)

### 避免重定向

* 重定向会延迟整个HTML文档是的传输，导致白屏一段时间

### 避免重复脚本

* ![](/public/images/h4.png)
* 搞一个脚本管理模块避免重复

### 配置ETAG

* 类似Expires，用于检测缓存和服务器上的数据是否匹配
* 形式是一段带引号的字符串
* ![](/public/images/h5.png)
* 不同服务器算出的ETAG不同，Apache和IIS的不同
* 如果服务器中使用了ETAG，代码中可以将其移除，使用Last-Modified

### 使AJAX可缓存

* 书里基本用了还是expires